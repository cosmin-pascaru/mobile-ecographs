import random
import numpy as np
import itertools

import time
from deap import algorithms
from deap import base
from deap import creator
from deap import tools
from deap.algorithms import varOr

from src.common.read_input import read_visits_cnt, read_distance_matrix
from src.common.utils import sec_to_str
from src.ga_v2_greedy_tours.evaluation import evaluate_greedy_tour_selection_tuple
from src.ga_v2_greedy_tours.individual import init_individual
from src.ga_v2_greedy_tours.operators import evaluate, crossover, mutate
from src.ga_v2_greedy_tours.params import GA_POP_SIZE, GaType, GA_TYPE, GA_PROB_CROSSOVER, GA_PROB_MUTATION, \
    GA_NR_GENERATIONS, GA_MU, GA_LAMBDA, GA_POP_LOAD_TYPE, PopulationLoadType, GA_TIME_LIMIT


def ea_mu_plus_lambda(population, toolbox, mu, lambda_, cxpb, mutpb, ngen,
                      stats=None, halloffame=None, verbose=__debug__, time_limit=None, print_best_delay=None):
    """This is the :math:`(\mu + \lambda)` evolutionary algorithm.

    :param population: A list of individuals.
    :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution
                    operators.
    :param mu: The number of individuals to select for the next generation.
    :param lambda\_: The number of children to produce at each generation.
    :param cxpb: The probability that an offspring is produced by crossover.
    :param mutpb: The probability that an offspring is produced by mutation.
    :param ngen: The number of generation.
    :param stats: A :class:`~deap.tools.Statistics` object that is updated
                  inplace, optional.
    :param halloffame: A :class:`~deap.tools.HallOfFame` object that will
                       contain the best individuals, optional.
    :param verbose: Whether or not to log the statistics.
    :param time_limit: Maximum run-time in seconds.
    :returns: The final population
    :returns: A class:`~deap.tools.Logbook` with the statistics of the
              evolution.

    The algorithm takes in a population and evolves it in place using the
    :func:`varOr` function. It returns the optimized population and a
    :class:`~deap.tools.Logbook` with the statistics of the evolution. The
    logbook will contain the generation number, the number of evalutions for
    each generation and the statistics if a :class:`~deap.tools.Statistics` is
    given as argument. The *cxpb* and *mutpb* arguments are passed to the
    :func:`varOr` function. The pseudocode goes as follow ::

        evaluate(population)
        for g in range(ngen):
            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
            evaluate(offspring)
            population = select(population + offspring, mu)

    First, the individuals having an invalid fitness are evaluated. Second,
    the evolutionary loop begins by producing *lambda_* offspring from the
    population, the offspring are generated by the :func:`varOr` function. The
    offspring are then evaluated and the next generation population is
    selected from both the offspring **and** the population. Finally, when
    *ngen* generations are done, the algorithm returns a tuple with the final
    population and a :class:`~deap.tools.Logbook` of the evolution.

    This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
    :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
    registered in the toolbox. This algorithm uses the :func:`varOr`
    variation.
    """
    logbook = tools.Logbook()
    logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

    # Evaluate the individuals with an invalid fitness
    invalid_ind = [ind for ind in population if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit

    if halloffame is not None:
        halloffame.update(population)

    record = stats.compile(population) if stats is not None else {}
    logbook.record(gen=0, nevals=len(invalid_ind), **record)
    if verbose:
        print(logbook.stream)

    start_time = time.time()
    last_print = start_time

    # Begin the generational process
    for gen in range(1, ngen + 1):
        # Vary the population
        offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        # Update the hall of fame with the generated individuals
        if halloffame is not None:
            halloffame.update(offspring)

        # Select the next generation population
        population[:] = toolbox.select(population + offspring, mu)

        # Update the statistics with the new population
        record = stats.compile(population) if stats is not None else {}
        logbook.record(gen=gen, nevals=len(invalid_ind), **record)

        if verbose:
            print(logbook.stream)

        time_so_far = time.time() - start_time

        if print_best_delay is not None:
            time_since_last_print = time.time() - last_print
            if time_since_last_print > print_best_delay:
                nr_tours, dist = evaluate_greedy_tour_selection_tuple(halloffame.items[0])
                with open('data/runs_ga_long.txt', 'a') as f:
                    f.write('{} {} {}\n'.format(nr_tours, dist, sec_to_str(time_so_far)))
                last_print = time.time()

        if time_limit is not None and time_so_far > time_limit:
            break

    return population, logbook
